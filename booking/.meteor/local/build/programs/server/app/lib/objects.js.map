{"version":3,"sources":["meteor://ðŸ’»app/lib/objects.js"],"names":[],"mappings":"yBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/lib/objects.js","sourcesContent":["getProvObject = function(date, providerName) {\n\tvar provObject = unusualDays.findOne({date: date, providerName: providerName});\n\tif (typeof provObject === \"undefined\") {\n\t\tprovObject = providers.findOne({name: providerName});\n\t}\n\treturn provObject;\n};\n\ngetBlockouts = function(providerName, date) {\n\t//Returns a complete list of blockouts for a given provider and day.\n\tvar day = moment(date).format(\"dddd\").toLowerCase();\n\tif (unusualDays.findOne({date: date})) {\n\t\tvar providerBlockouts = []\n\t} else {\n\t\ttry {\n\t\t\tproviderBlockouts = providers.findOne({name: providerName}, {fields: {\"blockouts\": 1}}).blockouts;\n\t\t} catch(e) {}//fails if no blockout object on the provider. this is normal.\n\n\t}\n\tvar singleDayBlockouts = blockouts.find(\n\t\t{date:\n\t\t\t{$gte: \tmoment(date).startOf('day').toDate(),\n\t\t\t$lt: moment(date).endOf('day').toDate()},\n\t\t\tproviderName: providerName}).fetch();\n\n\tvar ret = _.union(providerBlockouts, singleDayBlockouts);\n\tret = _.filter(ret, function(block) {\n\t\tif (typeof block !== \"undefined\" && !block.hasOwnProperty(\"day\")) {\n\t\t\treturn true;//this means the blockout is custom for today, thus kept\n\t\t} else if (typeof block !== \"undefined\") {\n\t\t\treturn (block.day === day || block.day === \"all\");\n\t\t}//this means the blockout is a recurring one for this provider, so kept if\n\t\t//is an everyday one or for this day of the week.\n\t\treturn false;\n\t});\n\t//console.log(ret);\n\treturn ret;\n};\n\ncheckDate = function(thisobj, isAppnt) {\n\t//Checks a given date falls within the bounds of the current day and does not overlap\n\t//appointments or blockouts\n\n\t\n\t//////////////////////////////////////////////////\n\t/////////////CHECKING APPOINTMENT OVERLAP\n\t/////////////////////////////////////////////////\n\tvar currentAppoint = thisobj.value;\n\tvar currentAppointEnd = moment(currentAppoint).add(parseInt(thisobj.field(\"length\").value), 'minutes');\n\tvar currentRange = moment(currentAppoint).twix(currentAppointEnd);\n\tvar queryStart = moment(thisobj.value).startOf('day').toDate();\n\tvar queryEnd = moment(thisobj.value).endOf('day').toDate();\n\t//console.log(JSON.stringify({date: {$gte: queryStart, $lt:queryEnd},providerName: thisobj.field(\"providerName\").value}));\n\tvar appoints = appointmentList.find({date: {$gte: queryStart, $lt:queryEnd},providerName: thisobj.field(\"providerName\").value}).fetch();\n\tvar ret;\n\t_.each(appoints, function(comparedAppoint) {\n\t\tvar comparedRange = moment(comparedAppoint.date)\n\t\t\t.twix(moment(comparedAppoint.date)\n\t\t\t\t.add(comparedAppoint.length, \"minutes\"));\n\n\t\t//console.log(\"Comparing \" + currentRange.format() + \" with \" + comparedRange.format());\n\t\tvar overlaps = currentRange.overlaps(comparedRange);\n\t\tif (overlaps) {\n\t\t\tif (Meteor.isServer) {\n\t\t\t\tif (!(thisobj.docId === comparedAppoint._id)) {\n\t\t\t\t\tconsole.log(\"different appointments clashing\");\n\t\t\t\t\tret = \"overlappingDates\";\n\t\t\t\t\treturn \"overlappingDates\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Meteor.isClient) {\n\t\t\t\tif (!(Session.get(\"currentlyEditingDoc\") === comparedAppoint._id)) {\n\t\t\t\t\tconsole.log(\"different appointments clashing\");\n\t\t\t\t\tret = \"overlappingDates\";\n\t\t\t\t\treturn \"overlappingDates\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tif (typeof ret === \"string\") {\n\t\treturn ret;\n\t}\n\t\n\t\n};\n\n"]}