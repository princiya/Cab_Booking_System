{"version":3,"sources":["meteor://ðŸ’»app/lib/unusualdays.js"],"names":[],"mappings":"yBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/lib/unusualdays.js","sourcesContent":["checkBounds = function(thisobj) {\n\t//used for checking whether the new bounds of an unusual day are valid. Used on creation and on edit of hours\n\t//validity is determined by whether any appointments are currently out of bounds.\n\tif (Meteor.isServer) {\n\t\ttry {//existing\n\t\t\tvar cleanDate = moment(unusualDays.findOne(thisobj.docId).date);\n\t\t\tvar provider = unusualDays.findOne(thisobj.docId).providerName;\n\t\t} catch (e) {//new\n\t\t\tcleanDate = moment(thisobj.field(\"date\").value);\n\t\t\tprovider = thisobj.field(\"providerName\").value;\n\t\t}\n\t} else {//client\n\t\ttry {\n\t\t\tcleanDate = moment(unusualDays.findOne({date: Session.get('date')}).date);\n\t\t} catch (e) { //new unusual day.\n\t\t\tcleanDate = moment(Session.get('date'));\n\t\t}\n\t\tprovider = Session.get(\"selectedProviderName\");\n\t}\n\t//new start and end of working day\n\tvar providerObj = providers.findOne({name: provider});\n\tif(thisobj.key ===\"startTime\") {\n\t\tvar startDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(thisobj.value).toDate();\n\t\tvar endDate = cleanDate.\n\t\tclone().\n\t\ttz(\"Pacific/Auckland\").\n\t\thour(thisobj.field(\"endTime\").value).\n\t\tadd(providerObj.appointmentLength, \"minutes\").\n\t\ttoDate();\n\t} else {\n\t\tstartDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(thisobj.field(\"startTime\").value).toDate();\n\t\tendDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(thisobj.value).add(providerObj.appointmentLength, \"minutes\").toDate();\n\t}\n\n\tvar dayTwix = moment(startDate).twix(endDate);\n\n\t//start and end of day for query\n\t//console.log(cleanDate.format());\n\n\tvar midnight = moment(cleanDate).startOf(\"day\").toDate();\n\tvar midday = moment(cleanDate).endOf(\"day\").toDate();//it's not actually midday but fuck the police\n\tvar appoints = appointmentList.find({date: {$gte: midnight, $lt: midday},\n\t\tproviderName: provider}).fetch();\n\tvar theblockouts = getBlockouts();\n\tvar ret = null;\n\t_.each(_.union(appoints,theblockouts), function(appoint) {//check each appointment and blockout still fits\n\t\tconsole.log(\"comparing \"+appoint.time+\" to \"+dayTwix.format());\n\t\t//console.log(appoint);\n\t\tif (appoint.hasOwnProperty(\"date\")) {\n\t\t\tif(!dayTwix.engulfs(moment(appoint.date).twix(moment(appoint.date).add(appoint.length, 'minutes')))) {\n\t\t\t\tconsole.log(\"fail\");\n\t\t\t\tret =  \"dateOutOfBounds\";\n\t\t\t}\n\t\t} else { //this is a blockout from the provider\n\t\t\tvar blockStartDate = moment(cleanDate.tz('Pacific/Auckland').format('YYYY MM DD ') + appoint.time,\n\t\t\t\t\"YYYY MM DD HH:mm A\");\n\t\t\tvar blockTwix = moment(blockStartDate).twix(moment(blockStartDate).add(appoint.length, \"minutes\"));\n\t\t\tif (!(dayTwix.engulfs(blockTwix))) {\n\t\t\t\tconsole.log(\"fail\");\n\t\t\t\tret =  \"dateOutOfBounds\";\n\t\t\t}\n\t\t}\n\n\t});\n\treturn ret;\n};\nunusualDays = new Meteor.Collection(\"unusualDays\");\nunusualDays.attachSchema( new SimpleSchema({\n\tdate: {\n\t\ttype: Date,\n\t\tlabel: \"Date\",\n\t\tindex: 1,\n\t\tautoValue: function(isInsert) {\n\t\t\tif(!isInsert) {\n\t\t\t\tthis.unset();\n\t\t\t}\n\t\t}\n\t},\n\tproviderName: {\n\t\ttype: String,\n\t\tlabel: \"Provider Name\"\n\t\t// custom:\n\t\t//TODO: Make sure provider Name exists\n\t},\n\tnotes: {\n\t\ttype: String,\n\t\tlabel: \"Notes\",\n\t\toptional: true\n\t},\n\tstartTime: {\n\t\ttype: Number,\n\t\tlabel: \"Start Time\",\n\t\tmin:1,\n\t\tmax:23,\n\t\tcustom: function() {\n\t\t\tif (this.isSet) {\n\t\t\t\treturn checkBounds(this);\n\t\t\t}\n\t\t}\n\t},\n\tendTime: {\n\t\ttype: Number,\n\t\tlabel: \"End Time (24h time)\",\n\t\tautoValue: function() {\n\t\t\tif(!this.isSet && this.isInsert && this.field(\"providerName\").isSet) {\n\t\t\t\treturn providers.findOne({name: this.field(\"providerName\").value})[\"endTime\"];\n\t\t\t}\n\t\t},\n\t\tmin:2,\n\t\tmax:24,\n\t\tcustom: function(){\n\t\t\tif (this.isSet) {\n\t\t\t\tif (this.field(\"startTime\").value >= this.value){\n\t\t\t\t\treturn \"startAfterEnd\"\n\t\t\t\t}\n\t\t\t\treturn checkBounds(this);\n\t\t\t}\n\n\t\t}\n\t},\n\tappointmentLength: {\n\t\ttype: Number,\n\t\tlabel: \"Appointment Length\",\n\t\tmin: 1,\n\t\tmax: 60,\n\t\tcustom: function(){\n\t\t\tif (this.value % 5 !== 0){\n\t\t\t\treturn \"mod5\";\n\t\t\t}\n\t\t},\n\t\tautoValue: function() {\n\t\t\tif(this.isInsert && this.field(\"providerName\").isSet) {\n\t\t\t\treturn providers.findOne({name: this.field(\"providerName\").value})[\"appointmentLength\"];\n\t\t\t}\n\t\t}\n\t}\n}));\nunusualDays.simpleSchema().messages({\n\tmod5: \"[value] must be a multiple of 5.\",\n\tstartAfterEnd:\"Start Time must be before End Time.\",\n\tendBeforeStart:\"End time must be after Before time.\",\n\tdateOutOfBounds: \"An Appointment or Blockout would be put out of bounds by this change.\"\n});\n"]}