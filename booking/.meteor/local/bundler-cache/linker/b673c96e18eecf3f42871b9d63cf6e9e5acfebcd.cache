[{"type":"js","data":"/* Imports for global scope */\n\nCollection2 = Package['aldeed:collection2'].Collection2;\nKadira = Package['meteorhacks:kadira'].Kadira;\nRoles = Package['alanning:roles'].Roles;\n_ = Package.underscore._;\nSimpleSchema = Package['aldeed:simple-schema'].SimpleSchema;\nMongoObject = Package['aldeed:simple-schema'].MongoObject;\nSubsManager = Package['meteorhacks:subs-manager'].SubsManager;\nRouter = Package['iron:router'].Router;\nRouteController = Package['iron:router'].RouteController;\nmoment = Package['mrt:moment'].moment;\nReactiveVar = Package['reactive-var'].ReactiveVar;\nMongoInternals = Package.mongo.MongoInternals;\nMongo = Package.mongo.Mongo;\nTracker = Package.tracker.Tracker;\nDeps = Package.tracker.Deps;\nLog = Package.logging.Log;\nRandom = Package.random.Random;\nEJSON = Package.ejson.EJSON;\nSpacebars = Package.spacebars.Spacebars;\ncheck = Package.check.check;\nMatch = Package.check.Match;\nAccounts = Package['accounts-base'].Accounts;\nAccountsServer = Package['accounts-base'].AccountsServer;\nIron = Package['iron:core'].Iron;\nAccountsTemplates = Package['useraccounts:core'].AccountsTemplates;\nMeteor = Package.meteor.Meteor;\nWebApp = Package.webapp.WebApp;\nmain = Package.webapp.main;\nWebAppInternals = Package.webapp.WebAppInternals;\nDDP = Package['ddp-client'].DDP;\nDDPServer = Package['ddp-server'].DDPServer;\nLaunchScreen = Package['launch-screen'].LaunchScreen;\nBlaze = Package.ui.Blaze;\nUI = Package.ui.UI;\nHandlebars = Package.ui.Handlebars;\nT9n = Package['softwarerero:accounts-t9n'].T9n;\nAutoupdate = Package.autoupdate.Autoupdate;\nHTML = Package.htmljs.HTML;\n\n","servePath":"/packages/global-imports.js"},{"type":"js","data":"(function(){\n// Meteor.users.allow({\n// \tupdate: function(userId, doc, fieldNames, modifier) {\n// \t\tif (_.contains(Meteor.users.findOne(userId).roles, \"admin\")) {\n// \t\t\treturn true;\n// \t\t} else {\n// \t\t\treturn false;\n// \t\t}\n// \t}\n// });\n// Accounts.validateNewUser(function (user) {\n// \tconsole.log(user)\n// \ttry {\n// \t\tvar loggedInUser = Meteor.user();\n\n// \t\tif (Roles.userIsInRole(loggedInUser, ['admin'])) {\n// \t\t\treturn true;\n// \t\t}\n\n// \t\tthrow new Meteor.Error(403, \"Not authorized to create new users\");\n// \t} catch (e) {\n// \t\treturn true;\n// \t}\n\n// });\nSchema = {};\nSchema.UserProfile = new SimpleSchema({\n    firstName: {\n        type: String,\n        regEx: /^[a-zA-Z-]{2,25}$/,\n        optional: true\n    },\n    lastName: {\n        type: String,\n        regEx: /^[a-zA-Z]{2,25}$/,\n        optional: true\n    },\n    birthday: {\n        type: Date,\n        optional: true\n    },\n    gender: {\n        type: String,\n        allowedValues: ['Male', 'Female'],\n        optional: true\n    },\n    organization : {\n        type: String,\n        regEx: /^[a-z0-9A-z .]{3,30}$/,\n        optional: true\n    },\n});\n\nSchema.User = new SimpleSchema({\n    _id: {\n        type: String,\n        regEx: SimpleSchema.RegEx.Id\n    },\n    username: {\n        type: String,\n        regEx: /^[a-z0-9A-Z_]{3,15}$/,\n        // optional: true,\n        custom: function () {\n        \tconsole.log(this);\n        }\n    },\n    emails: {\n    \toptional: true,\n        type: [Object],\n    },\n    \"emails.$.address\": {\n    \toptional: true,\n        type: String,\n        regEx: SimpleSchema.RegEx.Email\n    },\n    \"emails.$.verified\": {\n    \toptional: true,\n        type: Boolean\n    },\n    createdAt: {\n        type: Date\n    },\n    profile: {\n        type: Schema.UserProfile,\n        optional: true\n    },\n    services: {\n        type: Object,\n        optional: true,\n        blackbox: true\n    },\n    // Add `roles` to your schema if you use the meteor-roles package.\n    // Note that when using this package, you must also specify the\n    // `Roles.GLOBAL_GROUP` group whenever you add a user to a role.\n    // Roles.addUsersToRoles(userId, [\"admin\"], Roles.GLOBAL_GROUP);\n    // You can't mix and match adding with and without a group since\n    // you will fail validation in some cases.\n    roles: {\n        type: [String],\n        optional: true,\n        blackbox: true,\n        allowedValues: ['booker', 'provider', 'admin']\n    },\n \tproviderName: {\n \t\ttype: String,\n \t\toptional: true\n \t}\n});\n\nMeteor.users.attachSchema(Schema.User);\n\n}).call(this);\n","servePath":"/lib/accounts.js","sourceMap":{"version":3,"sources":["meteor://ðŸ’»app/lib/accounts.js"],"names":[],"mappings":"YAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/lib/accounts.js","sourcesContent":["\n// Meteor.users.allow({\n// \tupdate: function(userId, doc, fieldNames, modifier) {\n// \t\tif (_.contains(Meteor.users.findOne(userId).roles, \"admin\")) {\n// \t\t\treturn true;\n// \t\t} else {\n// \t\t\treturn false;\n// \t\t}\n// \t}\n// });\n// Accounts.validateNewUser(function (user) {\n// \tconsole.log(user)\n// \ttry {\n// \t\tvar loggedInUser = Meteor.user();\n\n// \t\tif (Roles.userIsInRole(loggedInUser, ['admin'])) {\n// \t\t\treturn true;\n// \t\t}\n\n// \t\tthrow new Meteor.Error(403, \"Not authorized to create new users\");\n// \t} catch (e) {\n// \t\treturn true;\n// \t}\n\n// });\nSchema = {};\nSchema.UserProfile = new SimpleSchema({\n    firstName: {\n        type: String,\n        regEx: /^[a-zA-Z-]{2,25}$/,\n        optional: true\n    },\n    lastName: {\n        type: String,\n        regEx: /^[a-zA-Z]{2,25}$/,\n        optional: true\n    },\n    birthday: {\n        type: Date,\n        optional: true\n    },\n    gender: {\n        type: String,\n        allowedValues: ['Male', 'Female'],\n        optional: true\n    },\n    organization : {\n        type: String,\n        regEx: /^[a-z0-9A-z .]{3,30}$/,\n        optional: true\n    },\n});\n\nSchema.User = new SimpleSchema({\n    _id: {\n        type: String,\n        regEx: SimpleSchema.RegEx.Id\n    },\n    username: {\n        type: String,\n        regEx: /^[a-z0-9A-Z_]{3,15}$/,\n        // optional: true,\n        custom: function () {\n        \tconsole.log(this);\n        }\n    },\n    emails: {\n    \toptional: true,\n        type: [Object],\n    },\n    \"emails.$.address\": {\n    \toptional: true,\n        type: String,\n        regEx: SimpleSchema.RegEx.Email\n    },\n    \"emails.$.verified\": {\n    \toptional: true,\n        type: Boolean\n    },\n    createdAt: {\n        type: Date\n    },\n    profile: {\n        type: Schema.UserProfile,\n        optional: true\n    },\n    services: {\n        type: Object,\n        optional: true,\n        blackbox: true\n    },\n    // Add `roles` to your schema if you use the meteor-roles package.\n    // Note that when using this package, you must also specify the\n    // `Roles.GLOBAL_GROUP` group whenever you add a user to a role.\n    // Roles.addUsersToRoles(userId, [\"admin\"], Roles.GLOBAL_GROUP);\n    // You can't mix and match adding with and without a group since\n    // you will fail validation in some cases.\n    roles: {\n        type: [String],\n        optional: true,\n        blackbox: true,\n        allowedValues: ['booker', 'provider', 'admin']\n    },\n \tproviderName: {\n \t\ttype: String,\n \t\toptional: true\n \t}\n});\n\nMeteor.users.attachSchema(Schema.User);\n"]}},{"type":"js","data":"(function(){appointmentList = new Meteor.Collection(\"appointmentList\");\nappointmentList.attachSchema(new SimpleSchema({\n\tfirstname: {\n\t\ttype: String,\n\t\tlabel: \"First Name\",\n\t\tmax: 100\n\t},\n\tlastname: {\n\t\ttype: String,\n\t\tlabel: \"Last Name\",\n\t\tmax: 100\n\t},\n\tphone: {\n\t\ttype: String,\n\t\tlabel: \"Phone Number\",\n\t\toptional: true\n\t},\n\tnotes: {\n\t\ttype: String,\n\t\tlabel: \"Notes\",\n\t\toptional: true\n\t},\n\tdate: {\n\t\ttype: Date,\n\t\tlabel: \"Date\",\n\t\tindex: true,\n\t\tcustom: function() {\n\t\t\treturn checkDate(this, true);\n\t\t}\n\t},\n\tlength: {\n\t\ttype: Number,\n\t\tlabel: \"Appointment length\",\n\t\tmin: 5,\n\t\t//defaultValue: function() {\n\t\t//\tvar provObject = getProvObject(Session.get('date'), Session.get('selectedProviderName'));\n\t\t//\treturn provObject.appointmentLength;\n\t\t//},\n\t\tautoValue: function() {\n\t\t\tif (typeof this.value == 'undefined') {\n\t\t\t\tvar cleanDate = moment(this.field('date').value).startOf('day').toDate();\n\t\t\t\tvar provObject = getProvObject(cleanDate, this.field('providerName').value);\n\t\t\t\treturn provObject.appointmentLength;\n\t\t\t}\n\t\t},\n\t\tcustom: function(){\n\t\t\tif (this.value % 5 !== 0){\n\t\t\t\treturn \"multiple\";\n\t\t\t}\n\t\t}\n\t},\n\tproviderName: {\n\t\ttype: String,\n\t\tlabel: \"Provider Name\",\n\t\tautoform: {\n\t\t\tomit: true\n\t\t}\n\t},\n\tcreatedAt: {\n\t\ttype: Date,\n\t\tautoform: {\n\t\t\tomit: true\n\t\t},\n\t\tautoValue: function() {\n\t\t\tif (this.isInsert) {\n\t\t\t\treturn new Date();\n\t\t\t} else if (this.isUpsert) {\n\t\t\t\treturn {$setOnInsert: new Date()};\n\t\t\t} else {\n\t\t\t\tthis.unset();\n\t\t\t}\n\t\t}\n\t}\n}));\nappointmentList.simpleSchema().messages({\n\twtf: \"What did you do to that poor date oh god\",\n\tmultiple: \"[value] must be a multiple of 5.\", \n\toverlappingDates:\"That time overlaps another appointment.\",\n\toverlappingBlockout:\"That time overlaps a blockout.\",\n\tdateOutOfBounds: \"Appointment time must be within [value] o'clock.\"\n});\n\n}).call(this);\n","servePath":"/lib/appointmentList.js","sourceMap":{"version":3,"sources":["meteor://ðŸ’»app/lib/appointmentList.js"],"names":[],"mappings":"yBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/lib/appointmentList.js","sourcesContent":["appointmentList = new Meteor.Collection(\"appointmentList\");\nappointmentList.attachSchema(new SimpleSchema({\n\tfirstname: {\n\t\ttype: String,\n\t\tlabel: \"First Name\",\n\t\tmax: 100\n\t},\n\tlastname: {\n\t\ttype: String,\n\t\tlabel: \"Last Name\",\n\t\tmax: 100\n\t},\n\tphone: {\n\t\ttype: String,\n\t\tlabel: \"Phone Number\",\n\t\toptional: true\n\t},\n\tnotes: {\n\t\ttype: String,\n\t\tlabel: \"Notes\",\n\t\toptional: true\n\t},\n\tdate: {\n\t\ttype: Date,\n\t\tlabel: \"Date\",\n\t\tindex: true,\n\t\tcustom: function() {\n\t\t\treturn checkDate(this, true);\n\t\t}\n\t},\n\tlength: {\n\t\ttype: Number,\n\t\tlabel: \"Appointment length\",\n\t\tmin: 5,\n\t\t//defaultValue: function() {\n\t\t//\tvar provObject = getProvObject(Session.get('date'), Session.get('selectedProviderName'));\n\t\t//\treturn provObject.appointmentLength;\n\t\t//},\n\t\tautoValue: function() {\n\t\t\tif (typeof this.value == 'undefined') {\n\t\t\t\tvar cleanDate = moment(this.field('date').value).startOf('day').toDate();\n\t\t\t\tvar provObject = getProvObject(cleanDate, this.field('providerName').value);\n\t\t\t\treturn provObject.appointmentLength;\n\t\t\t}\n\t\t},\n\t\tcustom: function(){\n\t\t\tif (this.value % 5 !== 0){\n\t\t\t\treturn \"multiple\";\n\t\t\t}\n\t\t}\n\t},\n\tproviderName: {\n\t\ttype: String,\n\t\tlabel: \"Provider Name\",\n\t\tautoform: {\n\t\t\tomit: true\n\t\t}\n\t},\n\tcreatedAt: {\n\t\ttype: Date,\n\t\tautoform: {\n\t\t\tomit: true\n\t\t},\n\t\tautoValue: function() {\n\t\t\tif (this.isInsert) {\n\t\t\t\treturn new Date();\n\t\t\t} else if (this.isUpsert) {\n\t\t\t\treturn {$setOnInsert: new Date()};\n\t\t\t} else {\n\t\t\t\tthis.unset();\n\t\t\t}\n\t\t}\n\t}\n}));\nappointmentList.simpleSchema().messages({\n\twtf: \"What did you do to that poor date oh god\",\n\tmultiple: \"[value] must be a multiple of 5.\", \n\toverlappingDates:\"That time overlaps another appointment.\",\n\toverlappingBlockout:\"That time overlaps a blockout.\",\n\tdateOutOfBounds: \"Appointment time must be within [value] o'clock.\"\n});\n"]}},{"type":"js","data":"(function(){blockouts = new Meteor.Collection('blockouts');\n\nblockouts.attachSchema(new SimpleSchema({\n\ttitle: {\n\t\ttype: String,\n\t\tlabel: \"Title\",\n\t\tdefaultValue: \"Break\",\n\t},\n\tdate: {\n\t\ttype: Date,\n\t\tlabel: \"Blockout Date\",\n\t\tcustom: function() {\n\t\t\treturn checkDate(this, false);\n\t\t}\n\t},\n\tlength: {\n\t\ttype: Number,\n\t\tlabel: \"Length\",\n\t\tmin:5,\n\t\tdefaultValue: 15,\n\t\tcustom: function(){\n\t\t\tif (this.value % 5 !== 0){\n\t\t\t\treturn \"mod5\";\n\t\t\t}\n\t\t}\n\t},\n\tproviderName: {\n\t\ttype: String,\n\t\tlabel: \"Provider Name\"\n\t}\n}));\nblockouts.simpleSchema().messages({\n\t\n\tmultiple: \"[value] must be a multiple of 5.\",\n\toverlappingDates:\"That time overlaps a booked slot! Try Later\",\n\toverlappingBlockout:\"That time overlaps another blockout.\",\n\tdateOutOfBounds: \"Blockout time must be within [value] o'clock.\"\n});\n\n}).call(this);\n","servePath":"/lib/blockouts.js","sourceMap":{"version":3,"sources":["meteor://ðŸ’»app/lib/blockouts.js"],"names":[],"mappings":"yBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/lib/blockouts.js","sourcesContent":["blockouts = new Meteor.Collection('blockouts');\n\nblockouts.attachSchema(new SimpleSchema({\n\ttitle: {\n\t\ttype: String,\n\t\tlabel: \"Title\",\n\t\tdefaultValue: \"Break\",\n\t},\n\tdate: {\n\t\ttype: Date,\n\t\tlabel: \"Blockout Date\",\n\t\tcustom: function() {\n\t\t\treturn checkDate(this, false);\n\t\t}\n\t},\n\tlength: {\n\t\ttype: Number,\n\t\tlabel: \"Length\",\n\t\tmin:5,\n\t\tdefaultValue: 15,\n\t\tcustom: function(){\n\t\t\tif (this.value % 5 !== 0){\n\t\t\t\treturn \"mod5\";\n\t\t\t}\n\t\t}\n\t},\n\tproviderName: {\n\t\ttype: String,\n\t\tlabel: \"Provider Name\"\n\t}\n}));\nblockouts.simpleSchema().messages({\n\t\n\tmultiple: \"[value] must be a multiple of 5.\",\n\toverlappingDates:\"That time overlaps a booked slot! Try Later\",\n\toverlappingBlockout:\"That time overlaps another blockout.\",\n\tdateOutOfBounds: \"Blockout time must be within [value] o'clock.\"\n});\n"]}},{"type":"js","data":"(function(){getProvObject = function(date, providerName) {\n\tvar provObject = unusualDays.findOne({date: date, providerName: providerName});\n\tif (typeof provObject === \"undefined\") {\n\t\tprovObject = providers.findOne({name: providerName});\n\t}\n\treturn provObject;\n};\n\ngetBlockouts = function(providerName, date) {\n\t//Returns a complete list of blockouts for a given provider and day.\n\tvar day = moment(date).format(\"dddd\").toLowerCase();\n\tif (unusualDays.findOne({date: date})) {\n\t\tvar providerBlockouts = []\n\t} else {\n\t\ttry {\n\t\t\tproviderBlockouts = providers.findOne({name: providerName}, {fields: {\"blockouts\": 1}}).blockouts;\n\t\t} catch(e) {}//fails if no blockout object on the provider. this is normal.\n\n\t}\n\tvar singleDayBlockouts = blockouts.find(\n\t\t{date:\n\t\t\t{$gte: \tmoment(date).startOf('day').toDate(),\n\t\t\t$lt: moment(date).endOf('day').toDate()},\n\t\t\tproviderName: providerName}).fetch();\n\n\tvar ret = _.union(providerBlockouts, singleDayBlockouts);\n\tret = _.filter(ret, function(block) {\n\t\tif (typeof block !== \"undefined\" && !block.hasOwnProperty(\"day\")) {\n\t\t\treturn true;//this means the blockout is custom for today, thus kept\n\t\t} else if (typeof block !== \"undefined\") {\n\t\t\treturn (block.day === day || block.day === \"all\");\n\t\t}//this means the blockout is a recurring one for this provider, so kept if\n\t\t//is an everyday one or for this day of the week.\n\t\treturn false;\n\t});\n\t//console.log(ret);\n\treturn ret;\n};\n\ncheckDate = function(thisobj, isAppnt) {\n\t//Checks a given date falls within the bounds of the current day and does not overlap\n\t//appointments or blockouts\n\n\t\n\t//////////////////////////////////////////////////\n\t/////////////CHECKING APPOINTMENT OVERLAP\n\t/////////////////////////////////////////////////\n\tvar currentAppoint = thisobj.value;\n\tvar currentAppointEnd = moment(currentAppoint).add(parseInt(thisobj.field(\"length\").value), 'minutes');\n\tvar currentRange = moment(currentAppoint).twix(currentAppointEnd);\n\tvar queryStart = moment(thisobj.value).startOf('day').toDate();\n\tvar queryEnd = moment(thisobj.value).endOf('day').toDate();\n\t//console.log(JSON.stringify({date: {$gte: queryStart, $lt:queryEnd},providerName: thisobj.field(\"providerName\").value}));\n\tvar appoints = appointmentList.find({date: {$gte: queryStart, $lt:queryEnd},providerName: thisobj.field(\"providerName\").value}).fetch();\n\tvar ret;\n\t_.each(appoints, function(comparedAppoint) {\n\t\tvar comparedRange = moment(comparedAppoint.date)\n\t\t\t.twix(moment(comparedAppoint.date)\n\t\t\t\t.add(comparedAppoint.length, \"minutes\"));\n\n\t\t//console.log(\"Comparing \" + currentRange.format() + \" with \" + comparedRange.format());\n\t\tvar overlaps = currentRange.overlaps(comparedRange);\n\t\tif (overlaps) {\n\t\t\tif (Meteor.isServer) {\n\t\t\t\tif (!(thisobj.docId === comparedAppoint._id)) {\n\t\t\t\t\tconsole.log(\"different appointments clashing\");\n\t\t\t\t\tret = \"overlappingDates\";\n\t\t\t\t\treturn \"overlappingDates\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Meteor.isClient) {\n\t\t\t\tif (!(Session.get(\"currentlyEditingDoc\") === comparedAppoint._id)) {\n\t\t\t\t\tconsole.log(\"different appointments clashing\");\n\t\t\t\t\tret = \"overlappingDates\";\n\t\t\t\t\treturn \"overlappingDates\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tif (typeof ret === \"string\") {\n\t\treturn ret;\n\t}\n\t\n\t\n};\n\n\n}).call(this);\n","servePath":"/lib/objects.js","sourceMap":{"version":3,"sources":["meteor://ðŸ’»app/lib/objects.js"],"names":[],"mappings":"yBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/lib/objects.js","sourcesContent":["getProvObject = function(date, providerName) {\n\tvar provObject = unusualDays.findOne({date: date, providerName: providerName});\n\tif (typeof provObject === \"undefined\") {\n\t\tprovObject = providers.findOne({name: providerName});\n\t}\n\treturn provObject;\n};\n\ngetBlockouts = function(providerName, date) {\n\t//Returns a complete list of blockouts for a given provider and day.\n\tvar day = moment(date).format(\"dddd\").toLowerCase();\n\tif (unusualDays.findOne({date: date})) {\n\t\tvar providerBlockouts = []\n\t} else {\n\t\ttry {\n\t\t\tproviderBlockouts = providers.findOne({name: providerName}, {fields: {\"blockouts\": 1}}).blockouts;\n\t\t} catch(e) {}//fails if no blockout object on the provider. this is normal.\n\n\t}\n\tvar singleDayBlockouts = blockouts.find(\n\t\t{date:\n\t\t\t{$gte: \tmoment(date).startOf('day').toDate(),\n\t\t\t$lt: moment(date).endOf('day').toDate()},\n\t\t\tproviderName: providerName}).fetch();\n\n\tvar ret = _.union(providerBlockouts, singleDayBlockouts);\n\tret = _.filter(ret, function(block) {\n\t\tif (typeof block !== \"undefined\" && !block.hasOwnProperty(\"day\")) {\n\t\t\treturn true;//this means the blockout is custom for today, thus kept\n\t\t} else if (typeof block !== \"undefined\") {\n\t\t\treturn (block.day === day || block.day === \"all\");\n\t\t}//this means the blockout is a recurring one for this provider, so kept if\n\t\t//is an everyday one or for this day of the week.\n\t\treturn false;\n\t});\n\t//console.log(ret);\n\treturn ret;\n};\n\ncheckDate = function(thisobj, isAppnt) {\n\t//Checks a given date falls within the bounds of the current day and does not overlap\n\t//appointments or blockouts\n\n\t\n\t//////////////////////////////////////////////////\n\t/////////////CHECKING APPOINTMENT OVERLAP\n\t/////////////////////////////////////////////////\n\tvar currentAppoint = thisobj.value;\n\tvar currentAppointEnd = moment(currentAppoint).add(parseInt(thisobj.field(\"length\").value), 'minutes');\n\tvar currentRange = moment(currentAppoint).twix(currentAppointEnd);\n\tvar queryStart = moment(thisobj.value).startOf('day').toDate();\n\tvar queryEnd = moment(thisobj.value).endOf('day').toDate();\n\t//console.log(JSON.stringify({date: {$gte: queryStart, $lt:queryEnd},providerName: thisobj.field(\"providerName\").value}));\n\tvar appoints = appointmentList.find({date: {$gte: queryStart, $lt:queryEnd},providerName: thisobj.field(\"providerName\").value}).fetch();\n\tvar ret;\n\t_.each(appoints, function(comparedAppoint) {\n\t\tvar comparedRange = moment(comparedAppoint.date)\n\t\t\t.twix(moment(comparedAppoint.date)\n\t\t\t\t.add(comparedAppoint.length, \"minutes\"));\n\n\t\t//console.log(\"Comparing \" + currentRange.format() + \" with \" + comparedRange.format());\n\t\tvar overlaps = currentRange.overlaps(comparedRange);\n\t\tif (overlaps) {\n\t\t\tif (Meteor.isServer) {\n\t\t\t\tif (!(thisobj.docId === comparedAppoint._id)) {\n\t\t\t\t\tconsole.log(\"different appointments clashing\");\n\t\t\t\t\tret = \"overlappingDates\";\n\t\t\t\t\treturn \"overlappingDates\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Meteor.isClient) {\n\t\t\t\tif (!(Session.get(\"currentlyEditingDoc\") === comparedAppoint._id)) {\n\t\t\t\t\tconsole.log(\"different appointments clashing\");\n\t\t\t\t\tret = \"overlappingDates\";\n\t\t\t\t\treturn \"overlappingDates\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tif (typeof ret === \"string\") {\n\t\treturn ret;\n\t}\n\t\n\t\n};\n\n"]}},{"type":"js","data":"(function(){providers =  new Meteor.Collection(\"providers\");\n// blockoutSchema = new SimpleSchema({\n\n// });\n// providers.attachSchema(blockoutSchema);\nproviders.attachSchema(new SimpleSchema({\n\tname: {\n\t\ttype: String,\n\t\tlabel: \"Name\",\n\t\tunique: true,\n\t\tindex: true\n\t},\n\tstartTime: {\n\t\ttype: Number,\n\t\tlabel: \"Usual Start Hour\",\n\t\tmin: 0,\n\t\tmax: 22,\n\t\t//TODO: When this is set, verify that no\n\t\t//current appointments voilate the new boundries\n\t\tdefaultValue: 9,\n\t\tcustom: function(){\n\t\t\tif (this.field(\"endTime\").value <= this.value){\n\t\t\t\treturn \"before\"\n\t\t\t}\n\t\t\tif (Meteor.isServer) {\n\t\t\t\tvar appoints = appointmentList.find({providerName: this.field('name').value}).fetch();\n\t\t\t\t//console.log(appoints);\n\t\t\t\tfor (var appointIndex in appoints) {\n\t\t\t\t\tif (appoints.hasOwnProperty(appointIndex)) {\n\t\t\t\t\t\tconsole.log(\"comparing \" + moment(appoints[appointIndex].date).hours() + \" with new hour: \"+this.value);\n\t\t\t\t\t\tif (moment(appoints[appointIndex].date).hours() < this.value) {\n\t\t\t\t\t\t\treturn \"wouldPushOutOfBounds\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tendTime: {\n\t\ttype: Number,\n\t\tlabel: \"Usual End Hour (24h)\",\n\t\tmin: 1,\n\t\tmax: 23,\n\t\tdefaultValue: 17,\n\t\tcustom: function(){\n\t\t\t//need to get server to iterate over all appointments\n\t\t\t//and check they are still valid in new bounds\n\t\t\tif (Meteor.isServer) {\n\t\t\t\tvar appoints = appointmentList.find({providerName: this.field('name').value}).fetch();\n\t\t\t\tfor (var appointIndex in appoints) {\n\t\t\t\t\tif (appoints.hasOwnProperty(appointIndex)) {\n\t\t\t\t\t\tif (moment(appoints[appointIndex].date).hours() > this.value) {\n\t\t\t\t\t\t\treturn \"wouldPushOutOfBounds\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tappointmentLength: {\n\t\ttype: Number,\n\t\tlabel: \"Usual Appointment Length\",\n\t\tmin: 5,\n\t\tmax: 120,\n\t\tdefaultValue: 15,\n\t\tcustom: function(){\n\t\t\tif (this.value % 5 !== 0){\n\t\t\t\treturn \"mod5\";\n\t\t\t}\n\t\t}\n\t},\n\tblockouts: {\n\t\ttype: [Object],\n\t\t// maxCount: 7,\n\t\toptional: true\n\t},\n\t\"blockouts.$.day\": {\n\t\ttype: String,\n\t\tlabel: \"Day of week\",\n\t\tallowedValues: [\n\t\t\"monday\",\n\t\t\"tuesday\",\n\t\t\"wednesday\",\n\t\t\"thursday\",\n\t\t\"friday\",\n\t\t\"saturday\",\n\t\t\"sunday\",\n\t\t\"all\" ]\n\t},\n\t\"blockouts.$.title\": {\n\t\ttype: String,\n\t\tlabel: \"Title\"\n\t},\n\t\"blockouts.$.time\": {\n\t\ttype: String,\n\t\tlabel: \"Start Time\",\n\t\tregEx: /^[0-2]?\\d:\\d\\d [APap]m|M$/,\n\t\tautoform: {\n\t\t\ttype: \"timePicker\"\n\t\t},\n\t\tcustom: function() {\n\t\t\tvar dateObj = moment(this.value, \"h:mm A\");\n\t\t\tvar compareTwix = moment(dateObj).twix(moment(dateObj).add(this.siblingField('length').value, \"minutes\"));\n\t\t\tvar provObject = providers.findOne(this.docId);\n\t\t\tvar exampleTwix = moment().startOf('day').hour(provObject.startTime).twix(\n\t\t\t\tmoment().startOf('day').hour(provObject.endTime));\n\t\t\tif (!exampleTwix.engulfs(compareTwix)) {\n\t\t\t\treturn \"dateOutOfBounds\"\n\t\t\t}\n\t\t}\n\t},\n\t\"blockouts.$.length\": {\n\t\ttype: Number,\n\t\tlabel: \"Length\",\n\t\tmin:5,\n\t\tdefaultValue: 15,\n\t\tautoform: {\n\t\t\tstep: 5\n\t\t},\n\t\tcustom: function(){\n\t\t\tif (this.value % 5 !== 0){\n\t\t\t\treturn \"mod5\";\n\t\t\t}\n\t\t}\n\t}\n}));\n\n// blockoutSchema.simpleSchema().messages({\n// \tmod5: \"[label] must be a multiple of 5\",\n// })\nproviders.simpleSchema().messages({\n\tmod5: \"[label] must be a multiple of 5\",\n\tbefore: \"[label] must be before End Time.\",\n\twouldPushOutOfBounds: \"This change would push appointments out of bounds.\",\n\tdateOutOfBounds: \"This repeating blockout is out of the usual day for this provider.\"\n});\nif (Meteor.isServer){\n\tif (providers.find({}).fetch().length === 0) {\n\t\tproviders.insert({name: \"Default Provider\"})\n\t}\n}\n\n// console.log(providers.find().fetch())\n\n}).call(this);\n","servePath":"/lib/providers.js","sourceMap":{"version":3,"sources":["meteor://ðŸ’»app/lib/providers.js"],"names":[],"mappings":"yBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/lib/providers.js","sourcesContent":["providers =  new Meteor.Collection(\"providers\");\n// blockoutSchema = new SimpleSchema({\n\n// });\n// providers.attachSchema(blockoutSchema);\nproviders.attachSchema(new SimpleSchema({\n\tname: {\n\t\ttype: String,\n\t\tlabel: \"Name\",\n\t\tunique: true,\n\t\tindex: true\n\t},\n\tstartTime: {\n\t\ttype: Number,\n\t\tlabel: \"Usual Start Hour\",\n\t\tmin: 0,\n\t\tmax: 22,\n\t\t//TODO: When this is set, verify that no\n\t\t//current appointments voilate the new boundries\n\t\tdefaultValue: 9,\n\t\tcustom: function(){\n\t\t\tif (this.field(\"endTime\").value <= this.value){\n\t\t\t\treturn \"before\"\n\t\t\t}\n\t\t\tif (Meteor.isServer) {\n\t\t\t\tvar appoints = appointmentList.find({providerName: this.field('name').value}).fetch();\n\t\t\t\t//console.log(appoints);\n\t\t\t\tfor (var appointIndex in appoints) {\n\t\t\t\t\tif (appoints.hasOwnProperty(appointIndex)) {\n\t\t\t\t\t\tconsole.log(\"comparing \" + moment(appoints[appointIndex].date).hours() + \" with new hour: \"+this.value);\n\t\t\t\t\t\tif (moment(appoints[appointIndex].date).hours() < this.value) {\n\t\t\t\t\t\t\treturn \"wouldPushOutOfBounds\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tendTime: {\n\t\ttype: Number,\n\t\tlabel: \"Usual End Hour (24h)\",\n\t\tmin: 1,\n\t\tmax: 23,\n\t\tdefaultValue: 17,\n\t\tcustom: function(){\n\t\t\t//need to get server to iterate over all appointments\n\t\t\t//and check they are still valid in new bounds\n\t\t\tif (Meteor.isServer) {\n\t\t\t\tvar appoints = appointmentList.find({providerName: this.field('name').value}).fetch();\n\t\t\t\tfor (var appointIndex in appoints) {\n\t\t\t\t\tif (appoints.hasOwnProperty(appointIndex)) {\n\t\t\t\t\t\tif (moment(appoints[appointIndex].date).hours() > this.value) {\n\t\t\t\t\t\t\treturn \"wouldPushOutOfBounds\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tappointmentLength: {\n\t\ttype: Number,\n\t\tlabel: \"Usual Appointment Length\",\n\t\tmin: 5,\n\t\tmax: 120,\n\t\tdefaultValue: 15,\n\t\tcustom: function(){\n\t\t\tif (this.value % 5 !== 0){\n\t\t\t\treturn \"mod5\";\n\t\t\t}\n\t\t}\n\t},\n\tblockouts: {\n\t\ttype: [Object],\n\t\t// maxCount: 7,\n\t\toptional: true\n\t},\n\t\"blockouts.$.day\": {\n\t\ttype: String,\n\t\tlabel: \"Day of week\",\n\t\tallowedValues: [\n\t\t\"monday\",\n\t\t\"tuesday\",\n\t\t\"wednesday\",\n\t\t\"thursday\",\n\t\t\"friday\",\n\t\t\"saturday\",\n\t\t\"sunday\",\n\t\t\"all\" ]\n\t},\n\t\"blockouts.$.title\": {\n\t\ttype: String,\n\t\tlabel: \"Title\"\n\t},\n\t\"blockouts.$.time\": {\n\t\ttype: String,\n\t\tlabel: \"Start Time\",\n\t\tregEx: /^[0-2]?\\d:\\d\\d [APap]m|M$/,\n\t\tautoform: {\n\t\t\ttype: \"timePicker\"\n\t\t},\n\t\tcustom: function() {\n\t\t\tvar dateObj = moment(this.value, \"h:mm A\");\n\t\t\tvar compareTwix = moment(dateObj).twix(moment(dateObj).add(this.siblingField('length').value, \"minutes\"));\n\t\t\tvar provObject = providers.findOne(this.docId);\n\t\t\tvar exampleTwix = moment().startOf('day').hour(provObject.startTime).twix(\n\t\t\t\tmoment().startOf('day').hour(provObject.endTime));\n\t\t\tif (!exampleTwix.engulfs(compareTwix)) {\n\t\t\t\treturn \"dateOutOfBounds\"\n\t\t\t}\n\t\t}\n\t},\n\t\"blockouts.$.length\": {\n\t\ttype: Number,\n\t\tlabel: \"Length\",\n\t\tmin:5,\n\t\tdefaultValue: 15,\n\t\tautoform: {\n\t\t\tstep: 5\n\t\t},\n\t\tcustom: function(){\n\t\t\tif (this.value % 5 !== 0){\n\t\t\t\treturn \"mod5\";\n\t\t\t}\n\t\t}\n\t}\n}));\n\n// blockoutSchema.simpleSchema().messages({\n// \tmod5: \"[label] must be a multiple of 5\",\n// })\nproviders.simpleSchema().messages({\n\tmod5: \"[label] must be a multiple of 5\",\n\tbefore: \"[label] must be before End Time.\",\n\twouldPushOutOfBounds: \"This change would push appointments out of bounds.\",\n\tdateOutOfBounds: \"This repeating blockout is out of the usual day for this provider.\"\n});\nif (Meteor.isServer){\n\tif (providers.find({}).fetch().length === 0) {\n\t\tproviders.insert({name: \"Default Provider\"})\n\t}\n}\n\n// console.log(providers.find().fetch())\n"]}},{"type":"js","data":"(function(){checkBounds = function(thisobj) {\n\t//used for checking whether the new bounds of an unusual day are valid. Used on creation and on edit of hours\n\t//validity is determined by whether any appointments are currently out of bounds.\n\tif (Meteor.isServer) {\n\t\ttry {//existing\n\t\t\tvar cleanDate = moment(unusualDays.findOne(thisobj.docId).date);\n\t\t\tvar provider = unusualDays.findOne(thisobj.docId).providerName;\n\t\t} catch (e) {//new\n\t\t\tcleanDate = moment(thisobj.field(\"date\").value);\n\t\t\tprovider = thisobj.field(\"providerName\").value;\n\t\t}\n\t} else {//client\n\t\ttry {\n\t\t\tcleanDate = moment(unusualDays.findOne({date: Session.get('date')}).date);\n\t\t} catch (e) { //new unusual day.\n\t\t\tcleanDate = moment(Session.get('date'));\n\t\t}\n\t\tprovider = Session.get(\"selectedProviderName\");\n\t}\n\t//new start and end of working day\n\tvar providerObj = providers.findOne({name: provider});\n\tif(thisobj.key ===\"startTime\") {\n\t\tvar startDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(thisobj.value).toDate();\n\t\tvar endDate = cleanDate.\n\t\tclone().\n\t\ttz(\"Pacific/Auckland\").\n\t\thour(thisobj.field(\"endTime\").value).\n\t\tadd(providerObj.appointmentLength, \"minutes\").\n\t\ttoDate();\n\t} else {\n\t\tstartDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(thisobj.field(\"startTime\").value).toDate();\n\t\tendDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(thisobj.value).add(providerObj.appointmentLength, \"minutes\").toDate();\n\t}\n\n\tvar dayTwix = moment(startDate).twix(endDate);\n\n\t//start and end of day for query\n\t//console.log(cleanDate.format());\n\n\tvar midnight = moment(cleanDate).startOf(\"day\").toDate();\n\tvar midday = moment(cleanDate).endOf(\"day\").toDate();//it's not actually midday but fuck the police\n\tvar appoints = appointmentList.find({date: {$gte: midnight, $lt: midday},\n\t\tproviderName: provider}).fetch();\n\tvar theblockouts = getBlockouts();\n\tvar ret = null;\n\t_.each(_.union(appoints,theblockouts), function(appoint) {//check each appointment and blockout still fits\n\t\tconsole.log(\"comparing \"+appoint.time+\" to \"+dayTwix.format());\n\t\t//console.log(appoint);\n\t\tif (appoint.hasOwnProperty(\"date\")) {\n\t\t\tif(!dayTwix.engulfs(moment(appoint.date).twix(moment(appoint.date).add(appoint.length, 'minutes')))) {\n\t\t\t\tconsole.log(\"fail\");\n\t\t\t\tret =  \"dateOutOfBounds\";\n\t\t\t}\n\t\t} else { //this is a blockout from the provider\n\t\t\tvar blockStartDate = moment(cleanDate.tz('Pacific/Auckland').format('YYYY MM DD ') + appoint.time,\n\t\t\t\t\"YYYY MM DD HH:mm A\");\n\t\t\tvar blockTwix = moment(blockStartDate).twix(moment(blockStartDate).add(appoint.length, \"minutes\"));\n\t\t\tif (!(dayTwix.engulfs(blockTwix))) {\n\t\t\t\tconsole.log(\"fail\");\n\t\t\t\tret =  \"dateOutOfBounds\";\n\t\t\t}\n\t\t}\n\n\t});\n\treturn ret;\n};\nunusualDays = new Meteor.Collection(\"unusualDays\");\nunusualDays.attachSchema( new SimpleSchema({\n\tdate: {\n\t\ttype: Date,\n\t\tlabel: \"Date\",\n\t\tindex: 1,\n\t\tautoValue: function(isInsert) {\n\t\t\tif(!isInsert) {\n\t\t\t\tthis.unset();\n\t\t\t}\n\t\t}\n\t},\n\tproviderName: {\n\t\ttype: String,\n\t\tlabel: \"Provider Name\"\n\t\t// custom:\n\t\t//TODO: Make sure provider Name exists\n\t},\n\tnotes: {\n\t\ttype: String,\n\t\tlabel: \"Notes\",\n\t\toptional: true\n\t},\n\tstartTime: {\n\t\ttype: Number,\n\t\tlabel: \"Start Time\",\n\t\tmin:1,\n\t\tmax:23,\n\t\tcustom: function() {\n\t\t\tif (this.isSet) {\n\t\t\t\treturn checkBounds(this);\n\t\t\t}\n\t\t}\n\t},\n\tendTime: {\n\t\ttype: Number,\n\t\tlabel: \"End Time (24h time)\",\n\t\tautoValue: function() {\n\t\t\tif(!this.isSet && this.isInsert && this.field(\"providerName\").isSet) {\n\t\t\t\treturn providers.findOne({name: this.field(\"providerName\").value})[\"endTime\"];\n\t\t\t}\n\t\t},\n\t\tmin:2,\n\t\tmax:24,\n\t\tcustom: function(){\n\t\t\tif (this.isSet) {\n\t\t\t\tif (this.field(\"startTime\").value >= this.value){\n\t\t\t\t\treturn \"startAfterEnd\"\n\t\t\t\t}\n\t\t\t\treturn checkBounds(this);\n\t\t\t}\n\n\t\t}\n\t},\n\tappointmentLength: {\n\t\ttype: Number,\n\t\tlabel: \"Appointment Length\",\n\t\tmin: 1,\n\t\tmax: 60,\n\t\tcustom: function(){\n\t\t\tif (this.value % 5 !== 0){\n\t\t\t\treturn \"mod5\";\n\t\t\t}\n\t\t},\n\t\tautoValue: function() {\n\t\t\tif(this.isInsert && this.field(\"providerName\").isSet) {\n\t\t\t\treturn providers.findOne({name: this.field(\"providerName\").value})[\"appointmentLength\"];\n\t\t\t}\n\t\t}\n\t}\n}));\nunusualDays.simpleSchema().messages({\n\tmod5: \"[value] must be a multiple of 5.\",\n\tstartAfterEnd:\"Start Time must be before End Time.\",\n\tendBeforeStart:\"End time must be after Before time.\",\n\tdateOutOfBounds: \"An Appointment or Blockout would be put out of bounds by this change.\"\n});\n\n}).call(this);\n","servePath":"/lib/unusualdays.js","sourceMap":{"version":3,"sources":["meteor://ðŸ’»app/lib/unusualdays.js"],"names":[],"mappings":"yBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/lib/unusualdays.js","sourcesContent":["checkBounds = function(thisobj) {\n\t//used for checking whether the new bounds of an unusual day are valid. Used on creation and on edit of hours\n\t//validity is determined by whether any appointments are currently out of bounds.\n\tif (Meteor.isServer) {\n\t\ttry {//existing\n\t\t\tvar cleanDate = moment(unusualDays.findOne(thisobj.docId).date);\n\t\t\tvar provider = unusualDays.findOne(thisobj.docId).providerName;\n\t\t} catch (e) {//new\n\t\t\tcleanDate = moment(thisobj.field(\"date\").value);\n\t\t\tprovider = thisobj.field(\"providerName\").value;\n\t\t}\n\t} else {//client\n\t\ttry {\n\t\t\tcleanDate = moment(unusualDays.findOne({date: Session.get('date')}).date);\n\t\t} catch (e) { //new unusual day.\n\t\t\tcleanDate = moment(Session.get('date'));\n\t\t}\n\t\tprovider = Session.get(\"selectedProviderName\");\n\t}\n\t//new start and end of working day\n\tvar providerObj = providers.findOne({name: provider});\n\tif(thisobj.key ===\"startTime\") {\n\t\tvar startDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(thisobj.value).toDate();\n\t\tvar endDate = cleanDate.\n\t\tclone().\n\t\ttz(\"Pacific/Auckland\").\n\t\thour(thisobj.field(\"endTime\").value).\n\t\tadd(providerObj.appointmentLength, \"minutes\").\n\t\ttoDate();\n\t} else {\n\t\tstartDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(thisobj.field(\"startTime\").value).toDate();\n\t\tendDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(thisobj.value).add(providerObj.appointmentLength, \"minutes\").toDate();\n\t}\n\n\tvar dayTwix = moment(startDate).twix(endDate);\n\n\t//start and end of day for query\n\t//console.log(cleanDate.format());\n\n\tvar midnight = moment(cleanDate).startOf(\"day\").toDate();\n\tvar midday = moment(cleanDate).endOf(\"day\").toDate();//it's not actually midday but fuck the police\n\tvar appoints = appointmentList.find({date: {$gte: midnight, $lt: midday},\n\t\tproviderName: provider}).fetch();\n\tvar theblockouts = getBlockouts();\n\tvar ret = null;\n\t_.each(_.union(appoints,theblockouts), function(appoint) {//check each appointment and blockout still fits\n\t\tconsole.log(\"comparing \"+appoint.time+\" to \"+dayTwix.format());\n\t\t//console.log(appoint);\n\t\tif (appoint.hasOwnProperty(\"date\")) {\n\t\t\tif(!dayTwix.engulfs(moment(appoint.date).twix(moment(appoint.date).add(appoint.length, 'minutes')))) {\n\t\t\t\tconsole.log(\"fail\");\n\t\t\t\tret =  \"dateOutOfBounds\";\n\t\t\t}\n\t\t} else { //this is a blockout from the provider\n\t\t\tvar blockStartDate = moment(cleanDate.tz('Pacific/Auckland').format('YYYY MM DD ') + appoint.time,\n\t\t\t\t\"YYYY MM DD HH:mm A\");\n\t\t\tvar blockTwix = moment(blockStartDate).twix(moment(blockStartDate).add(appoint.length, \"minutes\"));\n\t\t\tif (!(dayTwix.engulfs(blockTwix))) {\n\t\t\t\tconsole.log(\"fail\");\n\t\t\t\tret =  \"dateOutOfBounds\";\n\t\t\t}\n\t\t}\n\n\t});\n\treturn ret;\n};\nunusualDays = new Meteor.Collection(\"unusualDays\");\nunusualDays.attachSchema( new SimpleSchema({\n\tdate: {\n\t\ttype: Date,\n\t\tlabel: \"Date\",\n\t\tindex: 1,\n\t\tautoValue: function(isInsert) {\n\t\t\tif(!isInsert) {\n\t\t\t\tthis.unset();\n\t\t\t}\n\t\t}\n\t},\n\tproviderName: {\n\t\ttype: String,\n\t\tlabel: \"Provider Name\"\n\t\t// custom:\n\t\t//TODO: Make sure provider Name exists\n\t},\n\tnotes: {\n\t\ttype: String,\n\t\tlabel: \"Notes\",\n\t\toptional: true\n\t},\n\tstartTime: {\n\t\ttype: Number,\n\t\tlabel: \"Start Time\",\n\t\tmin:1,\n\t\tmax:23,\n\t\tcustom: function() {\n\t\t\tif (this.isSet) {\n\t\t\t\treturn checkBounds(this);\n\t\t\t}\n\t\t}\n\t},\n\tendTime: {\n\t\ttype: Number,\n\t\tlabel: \"End Time (24h time)\",\n\t\tautoValue: function() {\n\t\t\tif(!this.isSet && this.isInsert && this.field(\"providerName\").isSet) {\n\t\t\t\treturn providers.findOne({name: this.field(\"providerName\").value})[\"endTime\"];\n\t\t\t}\n\t\t},\n\t\tmin:2,\n\t\tmax:24,\n\t\tcustom: function(){\n\t\t\tif (this.isSet) {\n\t\t\t\tif (this.field(\"startTime\").value >= this.value){\n\t\t\t\t\treturn \"startAfterEnd\"\n\t\t\t\t}\n\t\t\t\treturn checkBounds(this);\n\t\t\t}\n\n\t\t}\n\t},\n\tappointmentLength: {\n\t\ttype: Number,\n\t\tlabel: \"Appointment Length\",\n\t\tmin: 1,\n\t\tmax: 60,\n\t\tcustom: function(){\n\t\t\tif (this.value % 5 !== 0){\n\t\t\t\treturn \"mod5\";\n\t\t\t}\n\t\t},\n\t\tautoValue: function() {\n\t\t\tif(this.isInsert && this.field(\"providerName\").isSet) {\n\t\t\t\treturn providers.findOne({name: this.field(\"providerName\").value})[\"appointmentLength\"];\n\t\t\t}\n\t\t}\n\t}\n}));\nunusualDays.simpleSchema().messages({\n\tmod5: \"[value] must be a multiple of 5.\",\n\tstartAfterEnd:\"Start Time must be before End Time.\",\n\tendBeforeStart:\"End time must be after Before time.\",\n\tdateOutOfBounds: \"An Appointment or Blockout would be put out of bounds by this change.\"\n});\n"]}},{"type":"js","data":"(function(){unusualDays.deny({\n\tremove: function(userId, doc) {\n\t\t//ensure that no appointments will be left stranded by this day being removed.\n\t\tvar provider = doc.providerName;\n\t\tvar cleanDate = moment(doc.date);\n\t\tvar provObj = providers.findOne({name: provider});\n\t\tvar startDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(provObj.startTime).toDate();\n\t\tvar endDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(provObj.endTime).toDate();\n\t\tvar dayTwix = moment(startDate).twix(endDate);\n\t\tconsole.log(dayTwix.format());\n\t\t//build query\n\t\tvar midnight = moment(cleanDate).startOf(\"day\").toDate();\n\t\tvar midday = moment(cleanDate).endOf(\"day\").toDate();\n\t\tvar appoints = appointmentList.find({date: {$gte: midnight, $lt: midday},\n\t\t\tproviderName: provider}).fetch();\n\t\tvar ret = false;\n\t\t_.each(appoints, function(appoint) {\n\t\t\tconsole.log(appoint);\n\t\t\tif(!dayTwix.contains(appoint.date)) {\n\t\t\t\tconsole.log(\"fail\");\n\t\t\t\tret = true;\n\t\t\t}\n\t\t});\n\t\treturn ret;\n\t}\n});\n\nappointmentList.allow({\n\tinsert: function(userId, appointment) {\n\t\tif (Roles.userIsInRole(userId, 'provider') && appointment.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to add appointment for user other than herself.\")\n\t\t}\n\t\treturn true;\n\t},\n\tupdate: function(userId, appointment) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && appointment.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to edit appointment for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tremove:function(userId, appointment) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && appointment.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to delete appointment for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tfetch: [\"providerName\"]\n});\n\nblockouts.allow({\n\tinsert: function(userId, blockout) {\n\t\tif (Roles.userIsInRole(userId, 'provider') && blockout.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to add blockout for user other than herself.\")\n\t\t}\n\t\treturn true;\n\t},\n\tupdate: function(userId, blockout) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && blockout.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to edit blockout for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tremove:function(userId, blockout) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && blockout.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to delete blockout for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tfetch: [\"providerName\"]\n});\n\nMeteor.users.allow({\n\tupdate: function(userId, user) {\n\t\tif(Roles.userIsInRole(userId, 'admin')) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new Meteor.Error(403, \"Nice try punk. Only admins can edit users.\")\n\t},\n\tinsert: function(userId, user) {\n\t\tif(Roles.userIsInRole(userId, 'admin')) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new Meteor.Error(403, \"Nice try punk. Only admins can add users.\")\n\t},\n\tremove: function(userId, user) {\n\t\tif(Roles.userIsInRole(userId, 'admin')) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new Meteor.Error(403, \"Nice try punk. Only admins can delete users.\")\n\t}\n});\n\nunusualDays.allow({\n\tinsert: function(userId, unusualDay) {\n\t\tif (Roles.userIsInRole(userId, 'provider') && unusualDay.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to add unusualDay for user other than herself.\")\n\t\t}\n\t\treturn true;\n\t},\n\tupdate: function(userId, unusualDay) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && unusualDay.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to edit blockout for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tremove:function(userId, unusualDay) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && unusualDay.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to delete blockout for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tfetch: [\"providerName\"]\n});\n\nproviders.allow({\n\tinsert: function(userId, provider) {\n\t\tif (Roles.userIsInRole(userId, 'provider') && provider.name != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to add provider for user other than herself.\")\n\t\t}\n\t\treturn true;\n\t},\n\tupdate: function(userId, provider) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && provider.name != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to edit provider for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tremove:function(userId, provider) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && provider.name != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to delete provider for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tfetch: [\"name\"]\n});\n}).call(this);\n","servePath":"/server/dbrules.js","sourceMap":{"version":3,"sources":["meteor://ðŸ’»app/server/dbrules.js"],"names":[],"mappings":"yBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G","file":"/server/dbrules.js","sourcesContent":["unusualDays.deny({\n\tremove: function(userId, doc) {\n\t\t//ensure that no appointments will be left stranded by this day being removed.\n\t\tvar provider = doc.providerName;\n\t\tvar cleanDate = moment(doc.date);\n\t\tvar provObj = providers.findOne({name: provider});\n\t\tvar startDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(provObj.startTime).toDate();\n\t\tvar endDate = cleanDate.clone().tz(\"Pacific/Auckland\").hour(provObj.endTime).toDate();\n\t\tvar dayTwix = moment(startDate).twix(endDate);\n\t\tconsole.log(dayTwix.format());\n\t\t//build query\n\t\tvar midnight = moment(cleanDate).startOf(\"day\").toDate();\n\t\tvar midday = moment(cleanDate).endOf(\"day\").toDate();\n\t\tvar appoints = appointmentList.find({date: {$gte: midnight, $lt: midday},\n\t\t\tproviderName: provider}).fetch();\n\t\tvar ret = false;\n\t\t_.each(appoints, function(appoint) {\n\t\t\tconsole.log(appoint);\n\t\t\tif(!dayTwix.contains(appoint.date)) {\n\t\t\t\tconsole.log(\"fail\");\n\t\t\t\tret = true;\n\t\t\t}\n\t\t});\n\t\treturn ret;\n\t}\n});\n\nappointmentList.allow({\n\tinsert: function(userId, appointment) {\n\t\tif (Roles.userIsInRole(userId, 'provider') && appointment.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to add appointment for user other than herself.\")\n\t\t}\n\t\treturn true;\n\t},\n\tupdate: function(userId, appointment) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && appointment.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to edit appointment for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tremove:function(userId, appointment) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && appointment.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to delete appointment for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tfetch: [\"providerName\"]\n});\n\nblockouts.allow({\n\tinsert: function(userId, blockout) {\n\t\tif (Roles.userIsInRole(userId, 'provider') && blockout.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to add blockout for user other than herself.\")\n\t\t}\n\t\treturn true;\n\t},\n\tupdate: function(userId, blockout) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && blockout.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to edit blockout for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tremove:function(userId, blockout) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && blockout.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to delete blockout for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tfetch: [\"providerName\"]\n});\n\nMeteor.users.allow({\n\tupdate: function(userId, user) {\n\t\tif(Roles.userIsInRole(userId, 'admin')) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new Meteor.Error(403, \"Nice try punk. Only admins can edit users.\")\n\t},\n\tinsert: function(userId, user) {\n\t\tif(Roles.userIsInRole(userId, 'admin')) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new Meteor.Error(403, \"Nice try punk. Only admins can add users.\")\n\t},\n\tremove: function(userId, user) {\n\t\tif(Roles.userIsInRole(userId, 'admin')) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new Meteor.Error(403, \"Nice try punk. Only admins can delete users.\")\n\t}\n});\n\nunusualDays.allow({\n\tinsert: function(userId, unusualDay) {\n\t\tif (Roles.userIsInRole(userId, 'provider') && unusualDay.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to add unusualDay for user other than herself.\")\n\t\t}\n\t\treturn true;\n\t},\n\tupdate: function(userId, unusualDay) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && unusualDay.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to edit blockout for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tremove:function(userId, unusualDay) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && unusualDay.providerName != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to delete blockout for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tfetch: [\"providerName\"]\n});\n\nproviders.allow({\n\tinsert: function(userId, provider) {\n\t\tif (Roles.userIsInRole(userId, 'provider') && provider.name != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to add provider for user other than herself.\")\n\t\t}\n\t\treturn true;\n\t},\n\tupdate: function(userId, provider) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && provider.name != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to edit provider for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tremove:function(userId, provider) {\n\n\t\tif (Roles.userIsInRole(userId, 'provider') && provider.name != Meteor.users.findOne(userId).providerName) {\n\t\t\tthrow new Meteor.Error (403, \"Provider tried to delete provider for user other than herself.\");\n\t\t}\n\t\treturn true;\n\t},\n\tfetch: [\"name\"]\n});"]}},{"type":"js","data":"(function(){Meteor.methods({\n    newUser: function () {\n        if (Roles.userIsInRole(this.userId, 'admin')) {\n            return Accounts.createUser({\n                username: \"newuser\",\n                email: \"fakeEmail@example.com\",\n                roles: [\"booker\"]\n                \n            })\n        }\n    },\n    deleteUser: function (id) {\n        if (Roles.userIsInRole(this.userId, 'admin')) {\n            return Meteor.users.remove(id);\n        }\n    },\n    forcePassword: function (userID, pass) {\n        if (Roles.userIsInRole(this.userId, 'admin')) {\n            return Accounts.setPassword(userID, pass);\n        }\n    }\n});\n\n//TODO: Define a method which removes a provider and ALL dependants\n\n}).call(this);\n","servePath":"/server/methods.js","sourceMap":{"version":3,"sources":["meteor://ðŸ’»app/server/methods.js"],"names":[],"mappings":"yBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/server/methods.js","sourcesContent":["Meteor.methods({\n    newUser: function () {\n        if (Roles.userIsInRole(this.userId, 'admin')) {\n            return Accounts.createUser({\n                username: \"newuser\",\n                email: \"fakeEmail@example.com\",\n                roles: [\"booker\"]\n                \n            })\n        }\n    },\n    deleteUser: function (id) {\n        if (Roles.userIsInRole(this.userId, 'admin')) {\n            return Meteor.users.remove(id);\n        }\n    },\n    forcePassword: function (userID, pass) {\n        if (Roles.userIsInRole(this.userId, 'admin')) {\n            return Accounts.setPassword(userID, pass);\n        }\n    }\n});\n\n//TODO: Define a method which removes a provider and ALL dependants\n"]}},{"type":"js","data":"(function(){Meteor.publish(\"appointmentList\", function (date, providerName) {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\tconsole.log(date);\n\tvar startDate = moment(date).startOf('day').toDate();\n\tvar endDate = moment(date).endOf('day').toDate();\n\ttry{\n\t\tconsole.log(\"appointmentList subscribed by \" + providers.findOne({name: providerName}).name + \" for date \"+ date);\n\t\t//console.log(\"query is \"+JSON.stringify({\"date\": {$gte: startDate, $lt: endDate}, \"providerName\": providerName}))\n\t} catch(e) {\n\t\tconsole.error(\"!!!! appointmentList subscribed without providerName!\");\n\t\t//this.stop();\n\t\t//return;\n\t}\n\treturn appointmentList.find({\"date\": {$gte: startDate, $lt: endDate}, \"providerName\": providerName});\n});\nMeteor.publish(null, function() {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\tif (Roles.userIsInRole(this.userId, 'provider')) {\n\t//\tconsole.log(\"providerSubscription subscribed by provider\");\n\t\treturn providers.find({name: Meteor.users.findOne(this.userId).providerName});\n\t}\n\t//console.log(\"providerSubscription subscribed by non-provider\");\n\treturn providers.find();\n});\nMeteor.publish(\"unusualDays\", function(thedate) {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\treturn unusualDays.find({date:thedate})\n});\nMeteor.publish(\"unusualDaysRange\", function(dateRangeStart, dateRangeEnd) {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\treturn unusualDays.find({date: {$gte: dateRangeStart, $lt: dateRangeEnd}})\n});\nMeteor.publish(null, function (){ \n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n  return Meteor.roles.find({});//publish all roles without sub\n});\nMeteor.publish(null, function(){\n\tif(!this.userId) {\n\t\tthis.stop();\n\t} else if (Roles.userIsInRole(this.userId, \"provider\")) {\n\t\treturn Meteor.users.find(this.userId, {fields: {providerName: 1}});\n\t}\n});//DOES THIS DO ANYTHING WTF\nMeteor.publish(\"userList\", function() {\n\tconsole.log(\"userlist caller is admin? \" + Roles.userIsInRole(this.userId, 'admin'));\n\tif(!this.userId || !Roles.userIsInRole(this.userId, 'admin')) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\treturn Meteor.users.find();\n});\nMeteor.publish(\"blockouts\", function(date, provider) {\n\ttry {\n\t//\tconsole.log(\"blockouts subscribed for:  \" + provider);\n\t}\n\tcatch(e) {\n\t\tconsole.error(\"blockouts subscribed without provider name\");\n\t\t//this.stop();\n\t\t//return;\n\t}\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\tvar startDate = moment(date).startOf('day').toDate();\n\tvar endDate = moment(date).endOf('day').toDate();\n\t//console.log({date: {$gte: startDate, $lt: endDate}, providerName: provider});\n\t//console.log(blockouts.find().fetch());\n\treturn blockouts.find({date: {$gte: startDate, $lt: endDate}, providerName: provider});\n});\nMeteor.publish(\"singleAppoint\", function(id) {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\tconsole.log('singleAppoint subbed: '+id);\n\treturn appointmentList.find(id);\n});\nMeteor.publish(\"singleBlockout\", function(id) {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\treturn blockouts.find(id);\n});\n}).call(this);\n","servePath":"/server/publications.js","sourceMap":{"version":3,"sources":["meteor://ðŸ’»app/server/publications.js"],"names":[],"mappings":"yBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G","file":"/server/publications.js","sourcesContent":["Meteor.publish(\"appointmentList\", function (date, providerName) {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\tconsole.log(date);\n\tvar startDate = moment(date).startOf('day').toDate();\n\tvar endDate = moment(date).endOf('day').toDate();\n\ttry{\n\t\tconsole.log(\"appointmentList subscribed by \" + providers.findOne({name: providerName}).name + \" for date \"+ date);\n\t\t//console.log(\"query is \"+JSON.stringify({\"date\": {$gte: startDate, $lt: endDate}, \"providerName\": providerName}))\n\t} catch(e) {\n\t\tconsole.error(\"!!!! appointmentList subscribed without providerName!\");\n\t\t//this.stop();\n\t\t//return;\n\t}\n\treturn appointmentList.find({\"date\": {$gte: startDate, $lt: endDate}, \"providerName\": providerName});\n});\nMeteor.publish(null, function() {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\tif (Roles.userIsInRole(this.userId, 'provider')) {\n\t//\tconsole.log(\"providerSubscription subscribed by provider\");\n\t\treturn providers.find({name: Meteor.users.findOne(this.userId).providerName});\n\t}\n\t//console.log(\"providerSubscription subscribed by non-provider\");\n\treturn providers.find();\n});\nMeteor.publish(\"unusualDays\", function(thedate) {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\treturn unusualDays.find({date:thedate})\n});\nMeteor.publish(\"unusualDaysRange\", function(dateRangeStart, dateRangeEnd) {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\treturn unusualDays.find({date: {$gte: dateRangeStart, $lt: dateRangeEnd}})\n});\nMeteor.publish(null, function (){ \n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n  return Meteor.roles.find({});//publish all roles without sub\n});\nMeteor.publish(null, function(){\n\tif(!this.userId) {\n\t\tthis.stop();\n\t} else if (Roles.userIsInRole(this.userId, \"provider\")) {\n\t\treturn Meteor.users.find(this.userId, {fields: {providerName: 1}});\n\t}\n});//DOES THIS DO ANYTHING WTF\nMeteor.publish(\"userList\", function() {\n\tconsole.log(\"userlist caller is admin? \" + Roles.userIsInRole(this.userId, 'admin'));\n\tif(!this.userId || !Roles.userIsInRole(this.userId, 'admin')) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\treturn Meteor.users.find();\n});\nMeteor.publish(\"blockouts\", function(date, provider) {\n\ttry {\n\t//\tconsole.log(\"blockouts subscribed for:  \" + provider);\n\t}\n\tcatch(e) {\n\t\tconsole.error(\"blockouts subscribed without provider name\");\n\t\t//this.stop();\n\t\t//return;\n\t}\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\tvar startDate = moment(date).startOf('day').toDate();\n\tvar endDate = moment(date).endOf('day').toDate();\n\t//console.log({date: {$gte: startDate, $lt: endDate}, providerName: provider});\n\t//console.log(blockouts.find().fetch());\n\treturn blockouts.find({date: {$gte: startDate, $lt: endDate}, providerName: provider});\n});\nMeteor.publish(\"singleAppoint\", function(id) {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\tconsole.log('singleAppoint subbed: '+id);\n\treturn appointmentList.find(id);\n});\nMeteor.publish(\"singleBlockout\", function(id) {\n\tif(!this.userId) {\n\t\tthis.stop();\n\t\treturn;\n\t}\n\treturn blockouts.find(id);\n});"]}},{"type":"js","data":"(function(){Meteor.startup(function() {\n\t//Kadira.connect('dJ6gZ6qfhtsLjqt59', 'b0f959b1-3714-41d9-848f-0cdd146c5ac3');\n\tif(Meteor.users.find().count() === 0) {\n\t\t\n\t\tid = Accounts.createUser({\n\t\t\tusername:\"booker\", \n\t\t\tpassword:\"booker\",\n\t\t\temail: \"booker@example.com\"\n\t\t});\n\t\tRoles.addUsersToRoles(id, \"booker\");\n\t\t\n\t\t\n\t}\n\t\n});\n\n}).call(this);\n","servePath":"/server/startup.js","sourceMap":{"version":3,"sources":["meteor://ðŸ’»app/server/startup.js"],"names":[],"mappings":"yBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/server/startup.js","sourcesContent":["Meteor.startup(function() {\n\t//Kadira.connect('dJ6gZ6qfhtsLjqt59', 'b0f959b1-3714-41d9-848f-0cdd146c5ac3');\n\tif(Meteor.users.find().count() === 0) {\n\t\t\n\t\tid = Accounts.createUser({\n\t\t\tusername:\"booker\", \n\t\t\tpassword:\"booker\",\n\t\t\temail: \"booker@example.com\"\n\t\t});\n\t\tRoles.addUsersToRoles(id, \"booker\");\n\t\t\n\t\t\n\t}\n\t\n});\n"]}}]